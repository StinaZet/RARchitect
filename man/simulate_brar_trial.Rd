% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulate_brar_trial.R
\name{simulate_brar_trial}
\alias{simulate_brar_trial}
\title{Simulate a Response Adaptive Randomization (RAR) Trial for Binary or Normal Outcomes}
\usage{
simulate_brar_trial(
  outcome_type = c("binary", "normal"),
  arms = 2,
  N,
  blocksize,
  priors,
  modelpar,
  tuning = 1,
  clipping = 0,
  burnin = 0,
  ensure_all_arms_sampled = FALSE,
  postprobmethod = "simulation",
  recruitment_rate = 1e+05,
  observation_delay = 0
)
}
\arguments{
\item{outcome_type}{Character. Specifies the type of outcome to simulate.
Must be either \code{"binary"} or \code{"normal"}.}

\item{arms}{Numeric. Number of arms in the trial.}

\item{N}{Numeric. Total sample size for the trial.}

\item{blocksize}{Numeric. (Fixed) size of each block of participants for the adaptive randomization.}

\item{priors}{Matrix. Defines the prior parameters for the Bayesian model of each arm.
The structure of this matrix depends on \code{outcome_type}:
\itemize{
\item If \code{outcome_type = "binary"}: A 2-row matrix where the first row contains the alpha
parameters and the second row contains the beta parameters for the Beta
distributions of each arm. The number of columns must match \code{arms}.
e.g., \code{matrix(c(1, 1, 1, 1), nrow = 2, byrow = TRUE)} for two arms with uniform Beta(1,1) priors.
\item If \code{outcome_type = "normal"}: A 2-row matrix containing the Normal prior parameters
for the mean of each arm (assuming known population variance). Each column
corresponds to an arm. Rows should be:
\enumerate{
\item Prior mean for the arm's mean.
\item Prior standard deviation of the arm's mean.
Example for two arms with N(0,1) priors for means:
\code{matrix(c(0, 0, 1, 1), nrow = 2, byrow = TRUE)}
}
}}

\item{modelpar}{Matrix or Numeric vector. Specifies the true parameters for each arm's
data generating process. The structure depends on \code{outcome_type}:
\itemize{
\item If \code{outcome_type = "binary"}: A numeric vector with the true success
probabilities for each Bernoulli arm. e.g., \code{c(0.6, 0.4)}.
\item If \code{outcome_type = "normal"}: A 2-row matrix specifying the true parameters
for each normal arm. Each column corresponds to an arm. Rows should be:
\enumerate{
\item True mean for the arm.
\item True standard deviation for the arm. It is assumed to be
the known population standard deviation for the purpose of posterior updates.
Example for two arms: \code{matrix(c(10, 8, 2, 2), nrow = 2, byrow = TRUE)}
}
}}

\item{tuning}{Numeric. A parameter (referred to as 'c' or 'gamma' in the
Wathen and Thall, 2017 paper) that shrinks allocation probabilities
towards equal randomization.
\itemize{
\item If \code{tuning = 1}, no shrinking occurs; original adaptive randomization probabilities are used.
\item As \code{tuning} approaches 0, probabilities shrink towards \code{1/arms} (equal randomization for \code{arms} arms).
\item A common value is 0.5. Defaults to 1.
}}

\item{clipping}{Character or Numeric. Forces a minimum and maximum probability
of selecting each arm.
\itemize{
\item If \code{clipping = 0} (Numeric), no clipping is applied.
\item If \code{clipping > 0} (Numeric), each arm's allocation probability is forced
to be at least \code{clipping} and at most \code{1 - (arms - 1) * clipping}.
Probabilities are then re-normalized to sum to 1.
It is \strong{required} that \code{clipping * arms <= 1} for consistent bounds.
\item If \code{clipping = "adaptive"} (Character), adaptive clipping is applied as
\verb{rho_min,t = 1/arms * (batch_number)^(-0.7)} (as in Hadad et al., 2021).
This option is only available when \code{outcome_type = "normal"}.
}}

\item{burnin}{Numeric. The number of initial participants allocated
before standard block processing begins. These participants are treated
as a single initial block, allocated using equal randomization. Defaults to 0.}

\item{ensure_all_arms_sampled}{Logical. If TRUE, ensures that at least
one participant is allocated to each arm within each block (if \code{blocksize >= arms}).
This is useful for ensuring initial exploration. Defaults to FALSE.}

\item{postprobmethod}{Character. (Applicable only when \code{outcome_type = "binary"}).
Method for calculating posterior probabilities. Can be \code{"simulation"} or \code{"exact"}. Defaults to "simulation".}

\item{recruitment_rate}{Numeric. The rate parameter (lambda)
for the Poisson process that governs patient recruitment for trial duration simulation.
This is the average number of patients arriving per unit of time (e.g., patients per month).
Must be a positive value. Defaults to 100000.}

\item{observation_delay}{Numeric. The fixed time from a participant's
enrollment until their outcome is observed, used for trial duration simulation. Defaults to 0.}
}
\value{
A data frame with \code{N} rows and the following columns:
\itemize{
\item \code{Batch}: The block number for each participant.
\item \verb{Recruitment time}: The time point at which each participant is recruited.
\item \verb{Outcome time}: The time point at which each participant's outcome is observed.
\item \code{Arm}: The arm selected for the participant (1 to \code{arms}).
\item \code{Outcome}: The outcome associated with the selected arm (binary 0/1 for "binary",
continuous for "normal").
\item \verb{AP arm X}: For each arm X, the allocation probability of Arm X for that block.
}
}
\description{
This function simulates a multi-arm clinical trial using Bayesian Response-Adaptive
Randomization (BRAR)/Thompson Sampling with either a Beta-Bernoulli model for
binary outcomes or a Normal-Normal conjugate model for normal outcomes
(assuming known population variance). It also simulates trial
duration based on a Poisson recruitment process.
}
\examples{
# Example 1: Simulate a Binary Outcome Trial
set.seed(101)
results_binary <- simulate_brar_trial(
outcome_type = "binary",
arms = 2, N = 100, blocksize = 10,
modelpar = c(0.6, 0.4),
priors = matrix(c(1, 1, 1, 1), nrow = 2, byrow = TRUE),
tuning = 1, clipping = 0, burnin = 0, ensure_all_arms_sampled = FALSE,
postprobmethod = "simulation", # Or "exact"
recruitment_rate = 5,
observation_delay = 30
)
head(results_binary)
print(paste("Observed success rate Arm 1:", mean(results_binary$Outcome[results_binary$Arm == 1])))

# Example 2: Simulate a Normal Outcome Trial with adaptive clipping
set.seed(102)
model_params_norm <- matrix(c(10, 8, 2, 2), nrow = 2, byrow = TRUE)
prior_params_norm <- matrix(c(0, 0, 1, 1), nrow = 2, byrow = TRUE)

results_normal <- simulate_brar_trial(
outcome_type = "normal",
arms = 2, N = 200, blocksize = 10,
priors = prior_params_norm,
modelpar = model_params_norm,
tuning = 0.5, clipping = "adaptive", burnin = 10, ensure_all_arms_sampled = TRUE,
recruitment_rate = 10,
observation_delay = 15
)
head(results_normal)
print(paste("Observed mean Arm 1:", mean(results_normal$Outcome[results_normal$Arm == 1])))

# Example 3: Binary trial with tuning and clipping
set.seed(103)
results_binary_tuned <- simulate_brar_trial(
outcome_type = "binary",
arms = 2, N = 150, blocksize = 15,
priors = matrix(c(1, 1, 1, 1), nrow = 2, byrow = TRUE),
modelpar = c(0.7, 0.5),
tuning = 0.5,
clipping = 0.05,
burnin = 0,
ensure_all_arms_sampled = TRUE,
postprobmethod = "exact",
recruitment_rate = 8,
observation_delay = 20
)
tail(results_binary_tuned)

}
